package %s

import (
    // "encoding/json"
    "sort"
    "math"
    "strconv"
    "reflect"
    "fmt"
    "path"
    "runtime"
    "strings"
)

// TLA expressions
type TLA interface {
	String() string
}

type Seq struct {
	elements []TLA
}

func (s Seq) String() string {
	ss := []string{}
	for _, v := range s.elements {
		ss = append(ss, v.String())
	}
	return fmt.Sprintf("<<%%s>>", strings.Join(ss, ", "))
}

type Record struct {
	elements map[string]TLA
}

func (s Record) String() string {
	keys := []string{}
	for k := range s.elements {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	ss := []string{}
	for _, k := range keys {
		v := s.elements[k]
		ss = append(ss, fmt.Sprintf("%%s |-> %%s", k, v.String()))
	}
	return fmt.Sprintf("[%%s]", strings.Join(ss, ", "))
}

type Set struct {
	elements map[string]TLA
}

func (s Set) String() string {
	keys := []string{}
	for k := range s.elements {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	ss := []string{}
	for _, k := range keys {
		v := s.elements[k]
		ss = append(ss, v.String())
	}
	return fmt.Sprintf("{%%s}", strings.Join(ss, ", "))
}

type Int struct {
	value int
}

func (s Int) String() string {
	return fmt.Sprintf("%%d", s.value)
}

type Bool struct {
	value bool
}

func (b Bool) String() string {
	return strconv.FormatBool(b.value)
}

type String struct {
	value string
}

func (s String) String() string {
	return s.value
}

// smart constructors

func boolean(b bool) Bool {
	return Bool{value: b}
}

func integer(n int) Int {
	return Int{value: n}
}

func str(s string) String {
	return String{value: s}
}

func set(elts ...TLA) Set {
	// avoid nil slice vs empty slice shenanigans
	if len(elts) == 0 {
		elts = []TLA{}
	}
	res := map[string]TLA{}
	for _, v := range elts {
		res[hash(v)] = v
	}
	return Set{elements: res}
}

func record(kvs ...TLA) Record {
	// avoid nil slice vs empty slice shenanigans
	if len(kvs) == 0 {
		kvs = []TLA{}
	}
	res := map[string]TLA{}
	for i := 0; i < len(kvs); i += 2 {
		res[kvs[i].(String).value] = kvs[i+1]
	}
	return Record{elements: res}
}

func seq(elts ...TLA) Seq {
	// avoid nil slice vs empty slice shenanigans
	if len(elts) == 0 {
		elts = []TLA{}
	}
	return Seq{elements: elts}
}

// library

func Some(a TLA) Seq {
	return seq(a)
}

func None() Seq {
	return seq()
}

func Append(a Seq, b TLA) Seq {
	return Seq{elements: append(a.elements, b)}
}

func AppendSeqs(a Seq, b Seq) Seq {
	return Seq{elements: append(a.elements, b.elements...)}
}

func Len(a Seq) Int {
	return integer(len(a.elements))
}

func Cardinality(a Set) Int {
	return integer(len(a.elements))
}

func SetUnion(a Set, b Set) Set {
	res := map[string]TLA{}
	for k, v := range a.elements {
		res[k] = v
	}
	for k, v := range b.elements {
		res[k] = v
	}
	return Set{elements: res}
}

func SetIn(a TLA, b Set) Bool {
	_, ok := b.elements[hash(a)]
	return boolean(ok)
}

func SetNotIn(a TLA, b Set) Bool {
	return boolean(!SetIn(a, b).value)
}

func RecordIndex(a Record, b String) TLA {
	return a.elements[b.value]
}

func TLAIndex(i int) int {
	return i - 1
}

func SeqIndex(a Seq, b Int) TLA {
	return a.elements[TLAIndex(b.value)]
}

func IndexInto(a TLA, b TLA) TLA {
    a1, ok1 := a.(Seq)
    b1, ok2 := b.(Int)
    if ok1 && ok2 {
        return SeqIndex(a1, b1)
    } else {
        return RecordIndex(a.(Record), b.(String))
    }
}

func IntPlus(a Int, b Int) Int {
	return integer(a.value + b.value)
}

func IntMinus(a Int, b Int) Int {
	return integer(a.value - b.value)
}

func IntMul(a Int, b Int) Int {
	return Int{value: a.value * b.value}
}

func IntDiv(a Int, b Int) Int {
	return Int{value: a.value / b.value}
}

func IntLt(a Int, b Int) Bool {
	return boolean(a.value < b.value)
}

func IntLte(a Int, b Int) Bool {
	return boolean(a.value <= b.value)
}

func IntGt(a Int, b Int) Bool {
	return boolean(a.value > b.value)
}

func IntGte(a Int, b Int) Bool {
	return boolean(a.value >= b.value)
}

func Eq(a TLA, b TLA) Bool {
	return boolean(reflect.DeepEqual(a, b))
}

func Not(b Bool) Bool {
	return boolean(!b.value)
}

func Neq(a TLA, b TLA) Bool {
	return Not(Eq(a, b))
}

func And(a Bool, b Bool) Bool {
	return boolean(a.value && b.value)
}

func Or(a Bool, b Bool) Bool {
	return boolean(a.value || b.value)
}

func IsFalse(a TLA) bool {
	return !a.(Bool).value
}

func IsTrue(a TLA) bool {
	return !IsFalse(a)
}

func ToSet(s Seq) Set {
    res := map[string]TLA{}
    for _, v := range s.elements {
        res[hash(v)] = v
    }
    return Set{elements: res}
}

func Except(r Record, k String, v TLA) Record {
    res := map[string]TLA{}
    for k1, v1 := range r.elements {
        res[k1] = v1
    }
    res[k.value] = v
    return Record{elements: res}
}

func BoundedForall(set Set, f func(TLA) Bool) Bool {
    res := true
    for _, v := range set.elements {
        res = res && IsTrue(f(v))
    }
    return Bool{value: res}
}

func BoundedExists(set Set, f func(TLA) Bool) Bool {
    res := false
    for _, v := range set.elements {
        res = res || IsTrue(f(v))
    }
    return Bool{value: res}
}

func FnConstruct(set Set, f func(TLA) TLA) Record {
    res := map[string]TLA{}
    for _, v := range set.elements {
        res[v.(String).value] = f(v)
    }
    return Record{elements: res}
}

func FoldSeq(f func(TLA, TLA) TLA, base TLA, seq Seq) TLA {
    res := base
    for _, v := range seq.elements {
        res = f(v, res)
    }
    return res
}

func Remove(s Seq, e TLA) Seq {
    res := []TLA{}
    for _, v := range s.elements {
        if IsFalse(Eq(v, e)) {
            res = append(res, v)
        }
    }
    return seq(res...)
}

func RemoveAt(s Seq, i Int) Seq {
    res := []TLA{}
    for j, v := range s.elements {
        if TLAIndex(i.value) != j {
            res = append(res, v)
        }
    }
    return seq(res...)
}

func SetToSeq(set Set) Seq {
    res := []TLA{}
    for _, v := range set.elements {
        res = append(res, v)
    }
    return seq(res...)
}

func Min(set Set) Int {
    res := math.MaxInt
    for _, v := range set.elements {
        if v.(Int).value < res {
            res = v.(Int).value
        }
    }
    return integer(res)
}

func Max(set Set) Int {
    res := math.MinInt
    for _, v := range set.elements {
        if v.(Int).value > res {
            res = v.(Int).value
        }
    }
    return integer(res)
}

func IsPrefix(prefix Seq, seq Seq) Bool {
	for i := 0; i < len(prefix.elements); i++ {
	    if IsFalse(Eq(prefix.elements[i], seq.elements[i])) {
	        return boolean(false)
	    }
	}
	return boolean(true)
}

func SelectSeq(s Seq, f func(TLA) TLA) Seq {
    res := []TLA{}
    for _, v := range s.elements {
        if IsTrue(f(v)) {
            res = append(res, v)
        }
    }
    return seq(res...)
}

func RangeIncl(lower Int, upper Int) Set {
    res := []TLA{}
    for i := lower.value; i <= upper.value; i++ {
        res = append(res, integer(i))
    }
    return set(res...)
}

// panic instead of returning error
var crash = true

func hash(a TLA) string {
	return a.String()
}

// this does not guarantee keys are sorted, which is a problem since map traversal is nondet
// func hash(a any) string {
// 	return fmt.Sprintf("%%+v", a)
// }

// this doesn't work for maps with non-string keys
// func hash(a any) string {
// 	s, _ := json.Marshal(a)
// 	return string(s)
// }

func thisFile() string {
	_, file, _, ok := runtime.Caller(1)
	if ok {
		return file
	}
	panic("could not get this file")
}

func getFileLine() (string, int) {
	for i := 1; i < 10; i++ {
		_, f, l, _ := runtime.Caller(i)
		if !strings.Contains(f, thisFile()) {
			return f, l
		}
	}
	panic("could not get file and line")
}

type State struct {
	%s
}

type EventType int

const (
	Initial = iota // special
	%s
)

func (e EventType) String() string {
	switch e {
	case Initial:
        return "Initial"
	%s
	default:
		panic(fmt.Sprintf("invalid %%d", e))
	}
}

type Event struct {
	typ    EventType
	params []TLA
	state  State
	file   string
	line   int
}

func printParams(ps []TLA) string {
	res := []string{}
	for _, v := range ps {
		res = append(res, fmt.Sprintf("%%+v", v))
	}
	return strings.Join(res, ", ")
}

func (e Event) String() string {
	return fmt.Sprintf("%%s(%%s);%%s:%%d;%%+v",
		e.typ, printParams(e.params), path.Base(e.file), e.line, e.state)
}

/*
type Constants struct {
    %%s
}
*/

type Monitor struct {
	// the goal of extra is just to remove maintaining our own aux state,
	// which is annoying and error-prone as it may have to be passed across several functions
	extra  []Event
	events []Event
	//constants Constants
}

func NewMonitor(/* constants Constants */) Monitor {
	return Monitor{
		extra:  []Event{},
		events: []Event{},
		//constants: constants,
	}
}

// TODO check initial

func (m *Monitor) CheckTrace() error {
	var prev Event
	for i, this := range m.events {
		if i == 0 {
			prev = this
		}
		switch this.typ {
		    case Initial:
                if err := m.CheckInitial(i, Event{}, this); err != nil {
                    return err
                }
		    %s
		}
		prev = this
	}
	return nil
}

func (m *Monitor) ShowTrace() {
	for i, v := range m.events {
		fmt.Printf("%%d;%%+v\n", i, v)
	}
}

func fail(format string, a ...any) error {
	if crash {
		panic(fmt.Sprintf(format, a...))
	}
	return fmt.Errorf(format, a...)
}

func (m *Monitor) CheckInitial(trace_i int, prev Event, this Event) error {
    %s
    return nil
}

%s

/*
func (m *Monitor) CheckInc(i int, prev Event, this Event) error {

	if prev.state.x.(int) <= 0 {
		return fail("precondition failed at %%d; expected x <= 0 but got %%s (prev: %%+v, this: %%+v)", i, prev.state.x, prev, this)
	}
	// check that new values are allowed
	if this.state.x != prev.state.x.(int)+1 { // for each var
		return fail("postcondition violated for x at %%d; should be %%+v but got %%+v (prev: %%+v, this: %%+v)", i,
			prev.state.x.(int)+1, this.state.x, prev, this)
	}

	// check unchanged
	if this.state.x != prev.state.x { // for each var
		return fail("unchanged violated for x at %%d; expected x to remain as %%+v but it is %%+v (prev: %%+v, this: %%+v)", i, prev.state.x, this.state.x, prev, this)
	}

	return nil
}
*/

// this state value can have nil fields
func (m *Monitor) CaptureVariable(v State, typ EventType, args ...TLA) error {

	e := Event{
		typ:    typ,
		params: args,
		state:  v,
		// no need to capture file and line here
	}
	m.extra = append(m.extra, e)
	return nil
}

func (m *Monitor) CaptureState(c State, typ EventType, args ...TLA) error {

	// override current values with extras
	// all have to pertain to this action
	for _, v := range m.extra {
		// sanity checks
		if v.typ != typ {
			return fmt.Errorf("type did not match")
		}
		for i, p := range v.params {
			if p != args[i] {
				return fmt.Errorf("arg %%d did not match", i)
			}
		}
		// there is no null in TLA+, and also all the struct fields are any, which are reference types

		// for each variable in state
		%s
	}

	// reset
	m.extra = []Event{}

	// record event
	file, line := getFileLine()
	e := Event{
		typ:    typ,
		params: args,
		state:  c,
		file:   file,
		line:   line,
	}

	m.events = append(m.events, e)

	return nil
}
