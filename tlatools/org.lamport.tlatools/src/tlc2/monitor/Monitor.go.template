package %s

// GENERATED CODE, DO NOT EDIT DIRECTLY

import (
    // "encoding/json"
    "sort"
    "math"
    "strconv"
    "reflect"
    "fmt"
    "path"
    "runtime"
    "strings"
)

// TLA expressions
type TLA interface {
	String() string
}

type Sequence struct {
	elements []TLA
}

func (s Sequence) String() string {
	ss := []string{}
	for _, v := range s.elements {
		ss = append(ss, v.String())
	}
	return fmt.Sprintf("<<%%s>>", strings.Join(ss, ", "))
}

type Record struct {
	elements map[string]TLA
}

func (s Record) String() string {
	keys := []string{}
	for k := range s.elements {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	ss := []string{}
	for _, k := range keys {
		v := s.elements[k]
		ss = append(ss, fmt.Sprintf("%%s |-> %%s", k, v.String()))
	}
	return fmt.Sprintf("[%%s]", strings.Join(ss, ", "))
}

type Set_ struct {
	elements map[string]TLA
}

func (s Set_) String() string {
	keys := []string{}
	for k := range s.elements {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	ss := []string{}
	for _, k := range keys {
		v := s.elements[k]
		ss = append(ss, v.String())
	}
	return fmt.Sprintf("{%%s}", strings.Join(ss, ", "))
}

type Integer struct {
	value int
}

func (s Integer) String() string {
	return fmt.Sprintf("%%d", s.value)
}

type Boolean struct {
	value bool
}

func (b Boolean) String() string {
	return strconv.FormatBool(b.value)
}

type String struct {
	value string
}

func (s String) String() string {
	return s.value
}

// smart constructors

func Bool(b bool) Boolean {
	return Boolean{value: b}
}

func Int(n int) Integer {
	return Integer{value: n}
}

func Str(s string) String {
	return String{value: s}
}

func Set(elts ...TLA) Set_ {
	// avoid nil slice vs empty slice shenanigans
	if len(elts) == 0 {
		elts = []TLA{}
	}
	res := map[string]TLA{}
	for _, v := range elts {
		res[hash(v)] = v
	}
	return Set_{elements: res}
}

func Rec(kvs ...TLA) Record {
	// avoid nil slice vs empty slice shenanigans
	if len(kvs) == 0 {
		kvs = []TLA{}
	}
	res := map[string]TLA{}
	for i := 0; i < len(kvs); i += 2 {
		res[kvs[i].(String).value] = kvs[i+1]
	}
	return Record{elements: res}
}

func Seq(elts ...TLA) Sequence {
	// avoid nil slice vs empty slice shenanigans
	if len(elts) == 0 {
		elts = []TLA{}
	}
	return Sequence{elements: elts}
}

// library

func Some(a TLA) Sequence {
	return Seq(a)
}

func None() Sequence {
	return Seq()
}

func Append(a Sequence, b TLA) Sequence {
	return Sequence{elements: append(a.elements, b)}
}

func AppendSeqs(a Sequence, b Sequence) Sequence {
	return Sequence{elements: append(a.elements, b.elements...)}
}

func Len(a Sequence) Integer {
	return Int(len(a.elements))
}

func Cardinality(a Set_) Integer {
	return Int(len(a.elements))
}

func SetUnion(a Set_, b Set_) Set_ {
	res := map[string]TLA{}
	for k, v := range a.elements {
		res[k] = v
	}
	for k, v := range b.elements {
		res[k] = v
	}
	return Set_{elements: res}
}

func SetIn(a TLA, b Set_) Boolean {
	_, ok := b.elements[hash(a)]
	return Bool(ok)
}

func SetNotIn(a TLA, b Set_) Boolean {
	return Bool(!SetIn(a, b).value)
}

func RecordIndex(a Record, b String) TLA {
	return a.elements[b.value]
}

func TLAIndex(i int) int {
	return i - 1
}

func SequenceIndex(a Sequence, b Integer) TLA {
	return a.elements[TLAIndex(b.value)]
}

func IndexInto(a TLA, b TLA) TLA {
    a1, ok1 := a.(Sequence)
    b1, ok2 := b.(Integer)
    if ok1 && ok2 {
        return SequenceIndex(a1, b1)
    } else {
        return RecordIndex(a.(Record), b.(String))
    }
}

func IntPlus(a Integer, b Integer) Integer {
	return Int(a.value + b.value)
}

func IntMinus(a Integer, b Integer) Integer {
	return Int(a.value - b.value)
}

func IntMul(a Integer, b Integer) Integer {
	return Integer{value: a.value * b.value}
}

func IntDiv(a Integer, b Integer) Integer {
	return Integer{value: a.value / b.value}
}

func IntLt(a Integer, b Integer) Boolean {
	return Bool(a.value < b.value)
}

func IntLte(a Integer, b Integer) Boolean {
	return Bool(a.value <= b.value)
}

func IntGt(a Integer, b Integer) Boolean {
	return Bool(a.value > b.value)
}

func IntGte(a Integer, b Integer) Boolean {
	return Bool(a.value >= b.value)
}

func Eq(a TLA, b TLA) Boolean {
	return Bool(reflect.DeepEqual(a, b))
}

func Not(b Boolean) Boolean {
	return Bool(!b.value)
}

func Neq(a TLA, b TLA) Boolean {
	return Not(Eq(a, b))
}

func And(a Boolean, b Boolean) Boolean {
	return Bool(a.value && b.value)
}

func Or(a Boolean, b Boolean) Boolean {
	return Bool(a.value || b.value)
}

func IsFalse(a TLA) bool {
	return !a.(Boolean).value
}

func IsTrue(a TLA) bool {
	return !IsFalse(a)
}

func ToSet(s Sequence) Set_ {
    res := map[string]TLA{}
    for _, v := range s.elements {
        res[hash(v)] = v
    }
    return Set_{elements: res}
}

func Except(r Record, k String, v TLA) Record {
    res := map[string]TLA{}
    for k1, v1 := range r.elements {
        res[k1] = v1
    }
    res[k.value] = v
    return Record{elements: res}
}

func BoundedForall(s Set_, f func(TLA) Boolean) Boolean {
    res := true
    for _, v := range s.elements {
        res = res && IsTrue(f(v))
    }
    return Boolean{value: res}
}

func BoundedExists(s Set_, f func(TLA) Boolean) Boolean {
    res := false
    for _, v := range s.elements {
        res = res || IsTrue(f(v))
    }
    return Boolean{value: res}
}

func FnConstruct(s Set_, f func(TLA) TLA) Record {
    res := map[string]TLA{}
    for _, v := range s.elements {
        res[v.(String).value] = f(v)
    }
    return Record{elements: res}
}

func FoldSeq(f func(TLA, TLA) TLA, base TLA, Seq Sequence) TLA {
    res := base
    for _, v := range Seq.elements {
        res = f(v, res)
    }
    return res
}

func Remove(s Sequence, e TLA) Sequence {
    res := []TLA{}
    for _, v := range s.elements {
        if IsFalse(Eq(v, e)) {
            res = append(res, v)
        }
    }
    return Seq(res...)
}

func RemoveAt(s Sequence, i Integer) Sequence {
    res := []TLA{}
    for j, v := range s.elements {
        if TLAIndex(i.value) != j {
            res = append(res, v)
        }
    }
    return Seq(res...)
}

func SetToSeq(s Set_) Sequence {
    res := []TLA{}
    for _, v := range s.elements {
        res = append(res, v)
    }
    return Seq(res...)
}

func Min(s Set_) Integer {
    res := math.MaxInt
    for _, v := range s.elements {
        if v.(Integer).value < res {
            res = v.(Integer).value
        }
    }
    return Int(res)
}

func Max(s Set_) Integer {
    res := math.MinInt
    for _, v := range s.elements {
        if v.(Integer).value > res {
            res = v.(Integer).value
        }
    }
    return Int(res)
}

func IsPrefix(prefix Sequence, Seq Sequence) Boolean {
	for i := 0; i < len(prefix.elements); i++ {
	    if IsFalse(Eq(prefix.elements[i], Seq.elements[i])) {
	        return Bool(false)
	    }
	}
	return Bool(true)
}

func SelectSequence(s Sequence, f func(TLA) TLA) Sequence {
    res := []TLA{}
    for _, v := range s.elements {
        if IsTrue(f(v)) {
            res = append(res, v)
        }
    }
    return Seq(res...)
}

func RangeIncl(lower Integer, upper Integer) Set_ {
    res := []TLA{}
    for i := lower.value; i <= upper.value; i++ {
        res = append(res, Int(i))
    }
    return Set(res...)
}

func d(a TLA) Boolean {
	// fmt.Printf("%%#v = %%+v\n", a, a)
	fmt.Printf("%%+v\n", a)
	return a.(Boolean)
}

func dAnd(a Boolean, b Boolean) Boolean {
	return d(And(a, b))
}

// panic instead of returning error
var crash = true

func hash(a TLA) string {
	return a.String()
}

// this does not guarantee keys are sorted, which is a problem since map traversal is nondet
// func hash(a any) string {
// 	return fmt.Sprintf("%%+v", a)
// }

// this doesn't work for maps with non-string keys
// func hash(a any) string {
// 	s, _ := json.Marshal(a)
// 	return string(s)
// }

func thisFile() string {
	_, file, _, ok := runtime.Caller(1)
	if ok {
		return file
	}
	panic("could not get this file")
}

func getFileLine() (string, int) {
	for i := 1; i < 10; i++ {
		_, f, l, _ := runtime.Caller(i)
		if !strings.Contains(f, thisFile()) {
			return f, l
		}
	}
	panic("could not get file and line")
}

type State struct {
	%s
}

type EventType int

const (
	Initial = iota // special
	%s
)

func (e EventType) String() string {
	switch e {
	case Initial:
        return "Initial"
	%s
	default:
		panic(fmt.Sprintf("invalid %%d", e))
	}
}

type Event struct {
	typ    EventType
	params []TLA
	state  State
	file   string
	line   int
}

func printParams(ps []TLA) string {
	res := []string{}
	for _, v := range ps {
		res = append(res, fmt.Sprintf("%%+v", v))
	}
	return strings.Join(res, ", ")
}

func (e Event) String() string {
	return fmt.Sprintf("%%s(%%s);%%s:%%d;%%+v",
		e.typ, printParams(e.params), path.Base(e.file), e.line, e.state)
}

/*
type Constants struct {
    %%s
}
*/

type Monitor struct {
	// the goal of extra is just to remove maintaining our own aux state,
	// which is annoying and error-prone as it may have to be passed across several functions
	extra  []Event
	events []Event
	//constants Constants
}

func NewMonitor(/* constants Constants */) *Monitor {
	return &Monitor{
		extra:  []Event{},
		events: []Event{},
		//constants: constants,
	}
}

func (m *Monitor) Reset() {
	m.events = []Event{}
}

func (m *Monitor) CheckTrace() error {
	var prev Event
	for i, this := range m.events {
		if i == 0 {
			prev = this
		}
		switch this.typ {
		    case Initial:
                if err := m.CheckInitial(i, Event{}, this); err != nil {
                    return err
                }
		    %s
		}
		prev = this
	}
	return nil
}

func (m *Monitor) ShowTrace() {
	for i, v := range m.events {
		fmt.Printf("%%d;%%+v\n", i, v)
	}
}

func fail(format string, a ...any) error {
	if crash {
		panic(fmt.Sprintf(format, a...))
	}
	return fmt.Errorf(format, a...)
}

func (m *Monitor) CheckInitial(trace_i int, prev Event, this Event) error {
    %s
    return nil
}

%s

/*
func (m *Monitor) CheckInc(i int, prev Event, this Event) error {

	if prev.state.x.(int) <= 0 {
		return fail("precondition failed at %%d; expected x <= 0 but got %%s (prev: %%+v, this: %%+v)", i, prev.state.x, prev, this)
	}
	// check that new values are allowed
	if this.state.x != prev.state.x.(int)+1 { // for each var
		return fail("postcondition violated for x at %%d; should be %%+v but got %%+v (prev: %%+v, this: %%+v)", i,
			prev.state.x.(int)+1, this.state.x, prev, this)
	}

	// check unchanged
	if this.state.x != prev.state.x { // for each var
		return fail("unchanged violated for x at %%d; expected x to remain as %%+v but it is %%+v (prev: %%+v, this: %%+v)", i, prev.state.x, this.state.x, prev, this)
	}

	return nil
}
*/

// this state value can have nil fields
func (m *Monitor) CaptureVariable(v State, typ EventType, args ...TLA) error {

	e := Event{
		typ:    typ,
		params: args,
		state:  v,
		// no need to capture file and line here
	}
	m.extra = append(m.extra, e)
	return nil
}

func (m *Monitor) CaptureState(c State, typ EventType, args ...TLA) error {

	// override current values with extras
	// all have to pertain to this action
	for _, v := range m.extra {
		// sanity checks
		if v.typ != typ {
			return fmt.Errorf("type did not match")
		}
		for i, p := range v.params {
			if p != args[i] {
				return fmt.Errorf("arg %%d did not match", i)
			}
		}
		// there is no null in TLA+, and also all the struct fields are any, which are reference types

		// for each variable in state
		%s
	}

	// reset
	m.extra = []Event{}

	// record event
	file, line := getFileLine()
	e := Event{
		typ:    typ,
		params: args,
		state:  c,
		file:   file,
		line:   line,
	}

	m.events = append(m.events, e)

	return nil
}
