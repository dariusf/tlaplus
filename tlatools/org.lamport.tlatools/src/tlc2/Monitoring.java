package tlc2;

import tla2sany.semantic.*;
import tlc2.value.IValue;
import tlc2.value.impl.IntValue;
import tlc2.value.impl.StringValue;
import util.UniqueString;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

public class Monitoring {

    static class MAction {
        List<SemanticNode> pre;
        List<SemanticNode> effects;

        public MAction(List<SemanticNode> pre, List<SemanticNode> effects) {
            this.pre = pre;
            this.effects = effects;
        }
    }

    public static void convert(Map<UniqueString, IValue> initialState, ModuleNode rootModule) {
        UniqueString moduleName = rootModule.getName();
        List<OpDeclNode> variables = Arrays.asList(rootModule.getVariableDecls());

        List<OpDefNode> definitions = rootModule.getDefinitions().stream()
                .filter(Monitoring::operatorWhitelist)
                .map(d -> (OpDefNode) d)
                .collect(Collectors.toList());


        String monitorFns = definitions.stream().map(d -> {
            if (!(d.getBody() instanceof OpApplNode)) {
                throw fail("not op appl node?");
            }
            MAction action = splitPreEff(d.getBody());
            String body = translate(action);
            String eq = "if !reflect.DeepEqual(m.state, c) {\npanic(\"state not equal\")\n}";
            return String.format("func (m *Monitor) %s(c State, params map[string]interface{}, msg map[string]interface{}) {\n%s\n%s\n}", d.getName(), eq, body);
        }).collect(Collectors.joining("\n"));

        String pkg = "monitoring";
        String varDecls = variables.stream().map(v -> String.format("%s interface{}", v.getName())).collect(Collectors.joining("\n"));
        String stateStruct = String.format("type State struct {\n%s\n}", varDecls);
        String monitorStruct = "type Monitor struct {\nstate State\n}";
        String initializers = initialState.entrySet().stream().map(e -> String.format("%s: %s,", e.getKey(), translateIValue(e.getValue()))).collect(Collectors.joining("\n"));
        String initial = String.format("func New() {\ns := State{\n%s\n}\nreturn Monitor{state: s}\n}", initializers);
        String packageDecl = String.format("package %s", pkg);
        String module = String.join("\n\n", packageDecl, stateStruct, monitorStruct, initial, monitorFns);

        Path filename = Paths.get(moduleName + ".go");
        try {
            Files.write(filename, module.getBytes());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        System.out.println(filename.toAbsolutePath());
    }

    private static boolean operatorWhitelist(SemanticNode d) {
        if (d instanceof OpDefNode) {
            String name = ((OpDefNode) d).getName().toString();
            if (name.contains("TypeOK") || name.contains("Spec") || name.contains("vars") ||
                    name.contains("Next") || name.contains("Init")) {
                // Init is ignored because it's already availale.
                // we should get the actions from Next but we just keep everything left instead.
                return false;
            } else if (List.of("Messages", "Receive", "Send", "ToSet", "Option", "Some", "None").contains(name)) {
                // Library functions
                return false;
            } else if (List.of("Terminating", "Termination").contains(name)) {
                // generated by the PlusCal translator
                return false;
            }
            return true;
        } else {
            throw fail("not an op def node?");
        }
    }

    private static boolean isNotPrimed(SemanticNode body) {
        if (isConstant(body)) {
            return true;
        } else if (body instanceof OpApplNode) {
            if (isPrimedVar(body)) {
                return false;
            }
            return operatorArgs(body).stream().allMatch(Monitoring::isNotPrimed);
        }
        return true;
    }

    private static boolean isVar(SemanticNode body) {
        return body instanceof OpApplNode && ((OpApplNode) body).getArgs().length == 0;
    }

    private static String getVarName(OpApplNode fml) {
        return fml.getOperator().getName().toString();
    }

    private static boolean isPrimedVar(SemanticNode body) {
        return ((OpApplNode) body).getOperator().getName().equals("'");
    }

    private static boolean isConstant(SemanticNode body) {
        return body instanceof StringNode || body instanceof NumeralNode;
    }

    private static ArrayList<ExprOrOpArgNode> operatorArgs(SemanticNode body) {
        if (!(body instanceof OpApplNode)) {
            throw fail("not an operator");
        }
        return new ArrayList<>(Arrays.asList(((OpApplNode) body).getArgs()));
    }

    /**
     * splits an operator body (represented as a $ConjList) into a list of preconditions and effects
     */
    private static MAction splitPreEff(SemanticNode body) {
        if (!(body instanceof OpApplNode)) {
            throw fail("not op app node?");
        }
        UniqueString name = ((OpApplNode) body).getOperator().getName();
        List<ExprOrOpArgNode> args = operatorArgs((OpApplNode) body);
        if (name.equals("$ConjList")) {
            List<SemanticNode> pre = new ArrayList<>();
            List<SemanticNode> effects = new ArrayList<>();
            args.stream().map(Monitoring::splitPreEff).forEach(m -> {
                pre.addAll(m.pre);
                effects.addAll(m.effects);
            });
            return new MAction(pre, effects);
        }
        boolean unprimed = args.stream().allMatch(Monitoring::isNotPrimed);
        // check if it involves primed variables
        if (unprimed) {
            return new MAction(List.of(body), List.of());
        } else {
            return new MAction(List.of(), List.of(body));
        }
    }

    private static String translate(MAction action) {
        return action.pre.stream().map(Monitoring::translatePre)
                .collect(Collectors.joining("\n")) + "\n\n" +
                action.effects.stream().map(Monitoring::translateEffect)
                        .collect(Collectors.joining("\n"));
    }

    private static String translateEffect(SemanticNode fml) {
        if (!(fml instanceof OpApplNode)) {
            throw fail("not app?");
        }
        String name = ((OpApplNode) fml).getOperator().getName().toString();
        List<ExprOrOpArgNode> args = operatorArgs(fml);
        if (name.equals("=")) {
            // figure out which is the variable
            SemanticNode var, val;
            if (isPrimedVar(args.get(0))) {
                var = args.get(0);
                val = args.get(1);
            } else {
                var = args.get(1);
                val = args.get(0);
            }
            String var1 = translateExpr(var);
            String val1 = translateExpr(val);
            if (var1.equals(val1)) {
                return String.format("// UNCHANGED %s", var1);
            } else {
                return String.format("%s = %s", var1, val1);
            }
        } else if (name.equals("$ConjList")) {
            return args.stream().map(Monitoring::translateEffect).collect(Collectors.joining("\n"));
        } else if (name.equals("$IfThenElse")) {
            return String.format("if %s {\n%s\n} else {\n%s\n}",
                    translateExpr(args.get(0)),
                    translateEffect(args.get(1)),
                    translateEffect(args.get(2)));
        }
        throw fail("unrecognised operator");
    }

    private static class GoExpr {
        List<String> defs = new ArrayList<>();
        String expr;
    }

//    private static List<String> goBlock(Object... args) {
//        List<String> res = new ArrayList<>();
//        Arrays.stream(args).forEach(a -> {
//            if (a instanceof String) {
//                res.add((String) a);
//            } else if (a instanceof GoExpr) {
//                res.addAll(((GoExpr) a).defs);
//                res.add(((GoExpr) a).expr);
//            } else {
//                throw fail("invalid");
//            }
//        });
//        return res;
//    }

    private static GoExpr goExpr(Object... args) {
        GoExpr res = new GoExpr();
        String expr = Arrays.stream(args).map(a -> {
            if (a instanceof String) {
                return (String) a;
            } else if (a instanceof GoExpr) {
                res.defs.addAll(((GoExpr) a).defs);
                return ((GoExpr) a).expr;
            } else {
                throw fail("invalid");
            }
        }).collect(Collectors.joining(" "));
        res.expr = expr;
        return res;
    }

    private static String translatePre(SemanticNode fml) {
        if (!(fml instanceof OpApplNode)) {
            throw fail("not app?");
        }
        String name = ((OpApplNode) fml).getOperator().getName().toString();
        List<ExprOrOpArgNode> args = operatorArgs(fml);
        if (name.equals("=")) {
            return String.format("if !(%s == %s) {\npanic(\"precondition failed\")\n}",
                    translateExpr(args.get(0)),
                    translateExpr(args.get(1)));
//            return goBlock("if");
        } else if (name.equals("Receive")) {
            return String.format("if !reflect.DeepEqual(%s, msg) {\npanic(\"message different\")\n}",
                    translateExpr(args.get(0)));
        }
        throw fail("unrecognised operator " + name);
    }

    private static String translateIValue(IValue v) {
        if (v instanceof StringValue) {
            return "\"" + ((StringValue) v).getVal() + "\"";
        } else if (v instanceof IntValue) {
            return v.toString();
        }
        throw fail("invalid type of value " + v.getClass().getSimpleName());
    }

    private static String translateExpr(SemanticNode fml) {
        if (isConstant(fml)) {
            if (fml instanceof StringNode) {
                return "\"" + ((StringNode) fml).getRep().toString() + "\"";
            } else if (fml instanceof NumeralNode) {
                return ((NumeralNode) fml).val() + "";
            }
            throw fail("unknown");
        } else if (isVar(fml)) {
            String name = getVarName((OpApplNode) fml);
            // primed variables are handled at a different level
//            return String.format("state[\"%s\"]", name);
            return String.format("m.%s", name);
//            return name;
        } else if (isPrimedVar(fml)) {
            List<ExprOrOpArgNode> args = operatorArgs(fml);
            return translateExpr(args.get(0));
        } else if (fml instanceof OpApplNode) {
            String name = ((OpApplNode) fml).getOperator().getName().toString();
            List<ExprOrOpArgNode> args = operatorArgs(fml);
            switch (name) {
                case "<":
                case "<=":
                case ">":
                case ">=":
                case "+":
                case "-":
                case "*":
                case "/":
                    return String.format("%s %s %s", translateExpr(args.get(0)), name, translateExpr(args.get(1)));
                case "$RcdConstructor":
                    return String.format("map[string]interface{}{%s}", args.stream().map(a -> {
                        OpApplNode op = (OpApplNode) a;
                        if (op.getOperator().getName().equals("$Pair")) {
                            ArrayList<ExprOrOpArgNode> args1 = operatorArgs(op);
                            return String.format("%s: %s", args1.get(0), args1.get(1));
                        } else {
                            throw fail("unexpected");
                        }
                    }).collect(Collectors.joining(", ")));
                default:
                    throw fail("unknown?" + name);
            }
        }
        throw fail("unknown?");
    }

    private static RuntimeException fail(String s) {
        RuntimeException e = new RuntimeException(s);
        e.printStackTrace();
        return e;
    }

//    // visitors are for applying a transformation uniformly across, not stuff where we decide whether or not to recurse
//    final ExplorerVisitor visitor = new ExplorerVisitor() {
//
//        List<MAction> actions = new ArrayList<>();
//        MAction current = null;
//        @Override
//        public void preVisit(ExploreNode exploreNode) {
////                        super.preVisit(exploreNode);
//            boolean skip = exploreNode instanceof ModuleNode
//                    || exploreNode instanceof Context
//                    || exploreNode instanceof FormalParamNode;
////                                || (exploreNode instanceof OpDefNode && ((OpDefNode) exploreNode).getBody() == null)
//
//            if (exploreNode instanceof SemanticNode) {
//                TreeNode stn = ((SemanticNode) exploreNode).stn;
//                if (stn == null) {
//                    skip = true;
//                } else {
//                    switch (stn.getFilename()) {
//                        case "--TLA+ BUILTINS--":
//                        case "Naturals":
//                        case "TLC":
//                            skip = true;
//                    }
//                }
//            }
//
//            if (skip) {
//                return;
//            }
//
//            if (exploreNode instanceof OpDefNode) {
//                current = new MAction();
//                System.out.println("action " + ((OpDefNode) exploreNode).getName());
//            } else if (exploreNode instanceof OpApplNode &&
//                    ((OpApplNode) exploreNode).getOperator().getName().equals("$ConjList")) {
//
//
//            } else {
//                System.out.println(exploreNode.getClass());
//            }
//        }
//
//        @Override
//        public void postVisit(ExploreNode exploreNode) {
//            super.postVisit(exploreNode);
//        }
//    };
//                rootModule.walkGraph(new Hashtable<>(), visitor);
////                visitor.done();
//
//                Arrays.stream(tool.getActions()).forEach(a -> {
//        int b = 1;
//    });
}
