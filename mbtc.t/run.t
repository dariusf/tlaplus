
  $ tlaroot=.. source ../build.sh
  tla2tools at ../tlatools/org.lamport.tlatools/dist/tla2tools.jar

  $ source test.sh

  $ monitor_check_show Stress
  1128 lines
  parse ok
  compile ok
  package monitor
  
  // Code generated by TLC. DO NOT EDIT.
  
  import (
  	"bytes"
  	"encoding/json"
  	"fmt"
  	"math"
  	"os"
  	"path"
  	"reflect"
  	"runtime"
  	"sort"
  	"strconv"
  	"strings"
  )
  
  // TLA expressions
  type TLA interface {
  	String() string
  	MarshalJSON() ([]byte, error)
  }
  
  type Sequence struct {
  	elements []TLA
  }
  
  func (s Sequence) MarshalJSON() ([]byte, error) {
  	return json.Marshal(s.elements)
  }
  
  func (s Sequence) String() string {
  	ss := []string{}
  	for _, v := range s.elements {
  		ss = append(ss, v.String())
  	}
  	return fmt.Sprintf("<<%s>>", strings.Join(ss, ", "))
  }
  
  type Record struct {
  	elements map[string]TLA
  }
  
  func (s Record) MarshalJSON() ([]byte, error) {
  	return json.Marshal(s.elements)
  }
  
  func (s Record) String() string {
  	keys := []string{}
  	for k := range s.elements {
  		keys = append(keys, k)
  	}
  	sort.Strings(keys)
  
  	ss := []string{}
  	for _, k := range keys {
  		v := s.elements[k]
  		ss = append(ss, fmt.Sprintf("%s |-> %s", k, v.String()))
  	}
  	return fmt.Sprintf("[%s]", strings.Join(ss, ", "))
  }
  
  type Set_ struct {
  	elements map[string]TLA
  }
  
  func (s Set_) MarshalJSON() ([]byte, error) {
  	return json.Marshal(map[string]any{"type": "set", "content": s.elements})
  }
  
  func (s Set_) String() string {
  	keys := []string{}
  	for k := range s.elements {
  		keys = append(keys, k)
  	}
  	sort.Strings(keys)
  
  	ss := []string{}
  	for _, k := range keys {
  		v := s.elements[k]
  		ss = append(ss, v.String())
  	}
  	return fmt.Sprintf("{%s}", strings.Join(ss, ", "))
  }
  
  type Integer struct {
  	value int
  }
  
  func (s Integer) String() string {
  	return fmt.Sprintf("%d", s.value)
  }
  
  func (s Integer) MarshalJSON() ([]byte, error) {
  	return json.Marshal(s.value)
  }
  
  type Boolean struct {
  	value bool
  }
  
  func (b Boolean) String() string {
  	return strconv.FormatBool(b.value)
  }
  
  func (s Boolean) MarshalJSON() ([]byte, error) {
  	return json.Marshal(s.value)
  }
  
  type String struct {
  	value string
  }
  
  func (s String) String() string {
  	return s.value
  }
  
  func (s String) MarshalJSON() ([]byte, error) {
  	return json.Marshal(s.value)
  }
  
  // smart constructors
  
  func Bool(b bool) Boolean {
  	return Boolean{value: b}
  }
  
  func Int(n int) Integer {
  	return Integer{value: n}
  }
  
  func Str(s string) String {
  	return String{value: s}
  }
  
  func Set(elts ...TLA) Set_ {
  	// avoid nil slice vs empty slice shenanigans
  	if len(elts) == 0 {
  		elts = []TLA{}
  	}
  	res := map[string]TLA{}
  	for _, v := range elts {
  		res[hash(v)] = v
  	}
  	return Set_{elements: res}
  }
  
  func Rec(kvs ...TLA) Record {
  	// avoid nil slice vs empty slice shenanigans
  	if len(kvs) == 0 {
  		kvs = []TLA{}
  	}
  	res := map[string]TLA{}
  	for i := 0; i < len(kvs); i += 2 {
  		res[kvs[i].(String).value] = kvs[i+1]
  	}
  	return Record{elements: res}
  }
  
  func Seq(elts ...TLA) Sequence {
  	// avoid nil slice vs empty slice shenanigans
  	if len(elts) == 0 {
  		elts = []TLA{}
  	}
  	return Sequence{elements: elts}
  }
  
  // library
  
  func Some(a TLA) Sequence {
  	return Seq(a)
  }
  
  func None() Sequence {
  	return Seq()
  }
  
  func Append(a Sequence, b TLA) Sequence {
  	return Sequence{elements: append(a.elements, b)}
  }
  
  func AppendSeqs(a Sequence, b Sequence) Sequence {
  	return Sequence{elements: append(a.elements, b.elements...)}
  }
  
  func Len(a Sequence) Integer {
  	return Int(len(a.elements))
  }
  
  func Cardinality(a Set_) Integer {
  	return Int(len(a.elements))
  }
  
  func SetUnion(a Set_, b Set_) Set_ {
  	res := map[string]TLA{}
  	for k, v := range a.elements {
  		res[k] = v
  	}
  	for k, v := range b.elements {
  		res[k] = v
  	}
  	return Set_{elements: res}
  }
  
  func SetIn(a TLA, b Set_) Boolean {
  	_, ok := b.elements[hash(a)]
  	return Bool(ok)
  }
  
  func SetNotIn(a TLA, b Set_) Boolean {
  	return Bool(!SetIn(a, b).value)
  }
  
  func RecordIndex(a Record, b String) TLA {
  	return a.elements[b.value]
  }
  
  func TLAIndex(i int) int {
  	return i - 1
  }
  
  func SequenceIndex(a Sequence, b Integer) TLA {
  	return a.elements[TLAIndex(b.value)]
  }
  
  func IndexInto(a TLA, b TLA) TLA {
  	a1, ok1 := a.(Sequence)
  	b1, ok2 := b.(Integer)
  	if ok1 && ok2 {
  		return SequenceIndex(a1, b1)
  	} else {
  		return RecordIndex(a.(Record), b.(String))
  	}
  }
  
  func IntPlus(a Integer, b Integer) Integer {
  	return Int(a.value + b.value)
  }
  
  func IntMinus(a Integer, b Integer) Integer {
  	return Int(a.value - b.value)
  }
  
  func IntMul(a Integer, b Integer) Integer {
  	return Integer{value: a.value * b.value}
  }
  
  func IntDiv(a Integer, b Integer) Integer {
  	return Integer{value: a.value / b.value}
  }
  
  func IntLt(a Integer, b Integer) Boolean {
  	return Bool(a.value < b.value)
  }
  
  func IntLte(a Integer, b Integer) Boolean {
  	return Bool(a.value <= b.value)
  }
  
  func IntGt(a Integer, b Integer) Boolean {
  	return Bool(a.value > b.value)
  }
  
  func IntGte(a Integer, b Integer) Boolean {
  	return Bool(a.value >= b.value)
  }
  
  func Eq(a TLA, b TLA) Boolean {
  	return Bool(reflect.DeepEqual(a, b))
  }
  
  func Not(b Boolean) Boolean {
  	return Bool(!b.value)
  }
  
  func Neq(a TLA, b TLA) Boolean {
  	return Not(Eq(a, b))
  }
  
  func And(a Boolean, b Boolean) Boolean {
  	return Bool(a.value && b.value)
  }
  
  func Or(a Boolean, b Boolean) Boolean {
  	return Bool(a.value || b.value)
  }
  
  func IsFalse(a TLA) bool {
  	return !a.(Boolean).value
  }
  
  func IsTrue(a TLA) bool {
  	return !IsFalse(a)
  }
  
  func ToSet(s Sequence) Set_ {
  	res := map[string]TLA{}
  	for _, v := range s.elements {
  		res[hash(v)] = v
  	}
  	return Set_{elements: res}
  }
  
  func Except(r Record, k String, v TLA) Record {
  	res := map[string]TLA{}
  	for k1, v1 := range r.elements {
  		res[k1] = v1
  	}
  	res[k.value] = v
  	return Record{elements: res}
  }
  
  func BoundedForall(s Set_, f func(TLA) Boolean) Boolean {
  	res := true
  	for _, v := range s.elements {
  		res = res && IsTrue(f(v))
  	}
  	return Boolean{value: res}
  }
  
  func BoundedExists(s Set_, f func(TLA) Boolean) Boolean {
  	res := false
  	for _, v := range s.elements {
  		res = res || IsTrue(f(v))
  	}
  	return Boolean{value: res}
  }
  
  func FnConstruct(s Set_, f func(TLA) TLA) Record {
  	res := map[string]TLA{}
  	for _, v := range s.elements {
  		res[v.(String).value] = f(v)
  	}
  	return Record{elements: res}
  }
  
  func FoldSeq(f func(TLA, TLA) TLA, base TLA, Seq Sequence) TLA {
  	res := base
  	for _, v := range Seq.elements {
  		res = f(v, res)
  	}
  	return res
  }
  
  func Remove(s Sequence, e TLA) Sequence {
  	res := []TLA{}
  	for _, v := range s.elements {
  		if IsFalse(Eq(v, e)) {
  			res = append(res, v)
  		}
  	}
  	return Seq(res...)
  }
  
  func RemoveAt(s Sequence, i Integer) Sequence {
  	res := []TLA{}
  	for j, v := range s.elements {
  		if TLAIndex(i.value) != j {
  			res = append(res, v)
  		}
  	}
  	return Seq(res...)
  }
  
  func SetToSeq(s Set_) Sequence {
  	res := []TLA{}
  	for _, v := range s.elements {
  		res = append(res, v)
  	}
  	return Seq(res...)
  }
  
  func Min(s Set_) Integer {
  	res := math.MaxInt
  	for _, v := range s.elements {
  		if v.(Integer).value < res {
  			res = v.(Integer).value
  		}
  	}
  	return Int(res)
  }
  
  func Max(s Set_) Integer {
  	res := math.MinInt
  	for _, v := range s.elements {
  		if v.(Integer).value > res {
  			res = v.(Integer).value
  		}
  	}
  	return Int(res)
  }
  
  func IsPrefix(prefix Sequence, Seq Sequence) Boolean {
  	for i := 0; i < len(prefix.elements); i++ {
  		if IsFalse(Eq(prefix.elements[i], Seq.elements[i])) {
  			return Bool(false)
  		}
  	}
  	return Bool(true)
  }
  
  func SelectSequence(s Sequence, f func(TLA) TLA) Sequence {
  	res := []TLA{}
  	for _, v := range s.elements {
  		if IsTrue(f(v)) {
  			res = append(res, v)
  		}
  	}
  	return Seq(res...)
  }
  
  func RangeIncl(lower Integer, upper Integer) Set_ {
  	res := []TLA{}
  	for i := lower.value; i <= upper.value; i++ {
  		res = append(res, Int(i))
  	}
  	return Set(res...)
  }
  
  func d(a TLA) Boolean {
  	// fmt.Printf("%#v = %+v\n", a, a)
  	fmt.Printf("%+v\n", a)
  	return a.(Boolean)
  }
  
  func dAnd(a Boolean, b Boolean) Boolean {
  	return d(And(a, b))
  }
  
  // panic instead of returning error
  var crash = true
  var writeLog = true
  var online = true
  
  var logfile *os.File
  var encoder *json.Encoder
  
  func lazyInitLogFile(node string) {
  	if logfile != nil {
  		return
  	}
  	var err error
  	logfile, err = os.Create(fmt.Sprintf("log-%s.ndjson", node))
  	if err != nil {
  		panic("could not create log file")
  	}
  	encoder = json.NewEncoder(logfile)
  	encoder.SetEscapeHTML(false)
  }
  
  func logEvent(node string, e Event) {
  	lazyInitLogFile(node)
  
  	// https://github.com/golang/go/issues/56630
  	// bs, _ := json.Marshal(e)
  	// logfile.Write(bs)
  	// logfile.WriteString("\n")
  	encoder.Encode(e)
  
  	_ = logfile.Sync()
  }
  
  func hash(a TLA) string {
  	return a.String()
  }
  
  // this does not guarantee keys are sorted, which is a problem since map traversal is nondet
  // func hash(a any) string {
  // 	return fmt.Sprintf("%+v", a)
  // }
  
  // this doesn't work for maps with non-string keys
  // func hash(a any) string {
  // 	s, _ := json.Marshal(a)
  // 	return string(s)
  // }
  
  func thisFile() string {
  	_, file, _, ok := runtime.Caller(1)
  	if ok {
  		return file
  	}
  	panic("could not get this file")
  }
  
  func getFileLine() (string, int) {
  	for i := 1; i < 10; i++ {
  		_, f, l, _ := runtime.Caller(i)
  		if !strings.Contains(f, thisFile()) {
  			return f, l
  		}
  	}
  	panic("could not get file and line")
  }
  
  type State struct {
  	X TLA
  }
  
  type EventType int
  
  const (
  	Initial = iota // special
  	A
  	A1
  	B
  	C
  	SendM
  	C1
  	D
  	E
  	F
  	G
  	H
  	H1
  	H2
  	H3
  	H4
  	a
  	b
  	c
  	I1
  	Sets
  )
  
  func (e EventType) String() string {
  	switch e {
  	case Initial:
  		return "Initial"
  	case A:
  		return "A"
  	case A1:
  		return "A1"
  	case B:
  		return "B"
  	case C:
  		return "C"
  	case SendM:
  		return "SendM"
  	case C1:
  		return "C1"
  	case D:
  		return "D"
  	case E:
  		return "E"
  	case F:
  		return "F"
  	case G:
  		return "G"
  	case H:
  		return "H"
  	case H1:
  		return "H1"
  	case H2:
  		return "H2"
  	case H3:
  		return "H3"
  	case H4:
  		return "H4"
  	case a:
  		return "a"
  	case b:
  		return "b"
  	case c:
  		return "c"
  	case I1:
  		return "I1"
  	case Sets:
  		return "Sets"
  	default:
  		panic(fmt.Sprintf("invalid %d", e))
  	}
  }
  
  func (s EventType) MarshalJSON() ([]byte, error) {
  	buffer := bytes.NewBufferString(`"`)
  	buffer.WriteString(s.String())
  	buffer.WriteString(`"`)
  	return buffer.Bytes(), nil
  }
  
  type Event struct {
  	Typ    EventType `json:"typ"`
  	Params []TLA     `json:"params"`
  	State  State     `json:"state"`
  	File   string    `json:"file"`
  	Line   int       `json:"line"`
  }
  
  func printParams(ps []TLA) string {
  	res := []string{}
  	for _, v := range ps {
  		res = append(res, fmt.Sprintf("%+v", v))
  	}
  	return strings.Join(res, ", ")
  }
  
  func (e Event) String() string {
  	return fmt.Sprintf("%s(%s);%s:%d;%+v",
  		e.Typ, printParams(e.Params), path.Base(e.File), e.Line, e.State)
  }
  
  /*
  type Constants struct {
      %s
  }
  */
  
  type Monitor struct {
  	// the goal of extra is just to remove maintaining our own aux state,
  	// which is annoying and error-prone as it may have to be passed across several functions
  	extra  []Event
  	events []Event
  	who    String
  	//constants Constants
  }
  
  func NewMonitor(who String /* constants Constants */) *Monitor {
  	return &Monitor{
  		who:    who,
  		extra:  []Event{},
  		events: []Event{},
  		//constants: constants,
  	}
  }
  
  func (m *Monitor) Reset() {
  	m.events = []Event{}
  }
  
  func (m *Monitor) CheckStates(current int, prev Event, this Event) error {
  	i := current
  	switch this.Typ {
  	case Initial:
  		if err := m.CheckInitial(i, Event{}, this); err != nil {
  			return err
  		}
  	case A:
  		if err := m.CheckA(i, prev, this); err != nil {
  			return err
  		}
  	case A1:
  		if err := m.CheckA1(i, prev, this); err != nil {
  			return err
  		}
  	case B:
  		if err := m.CheckB(i, prev, this); err != nil {
  			return err
  		}
  	case C:
  		if err := m.CheckC(i, prev, this); err != nil {
  			return err
  		}
  	case SendM:
  		if err := m.CheckSendM(this.Params[0], i, prev, this); err != nil {
  			return err
  		}
  	case C1:
  		if err := m.CheckC1(i, prev, this); err != nil {
  			return err
  		}
  	case D:
  		if err := m.CheckD(i, prev, this); err != nil {
  			return err
  		}
  	case E:
  		if err := m.CheckE(i, prev, this); err != nil {
  			return err
  		}
  	case F:
  		if err := m.CheckF(this.Params[0], i, prev, this); err != nil {
  			return err
  		}
  	case G:
  		if err := m.CheckG(i, prev, this); err != nil {
  			return err
  		}
  	case H:
  		if err := m.CheckH(i, prev, this); err != nil {
  			return err
  		}
  	case H1:
  		if err := m.CheckH1(i, prev, this); err != nil {
  			return err
  		}
  	case H2:
  		if err := m.CheckH2(i, prev, this); err != nil {
  			return err
  		}
  	case H3:
  		if err := m.CheckH3(i, prev, this); err != nil {
  			return err
  		}
  	case H4:
  		if err := m.CheckH4(i, prev, this); err != nil {
  			return err
  		}
  	case a:
  		if err := m.Checka(i, prev, this); err != nil {
  			return err
  		}
  	case b:
  		if err := m.Checkb(i, prev, this); err != nil {
  			return err
  		}
  	case c:
  		if err := m.Checkc(i, prev, this); err != nil {
  			return err
  		}
  	case I1:
  		if err := m.CheckI1(i, prev, this); err != nil {
  			return err
  		}
  	case Sets:
  		if err := m.CheckSets(i, prev, this); err != nil {
  			return err
  		}
  	}
  	return nil
  }
  
  func (m *Monitor) CheckTrace() error {
  	var prev Event
  	for i, this := range m.events {
  		if i == 0 {
  			prev = this
  		}
  		if err := m.CheckStates(i, prev, this); err != nil {
  			return err
  		}
  		prev = this
  	}
  	return nil
  }
  
  func (m *Monitor) CheckLast() error {
  	l := len(m.events)
  	if l < 1 {
  		return nil
  	}
  	if l == 1 {
  		return m.CheckInitial(0, m.events[0], m.events[0])
  	}
  	return m.CheckStates(l-1, m.events[l-2], m.events[l-1])
  }
  
  func (m *Monitor) ShowTrace() {
  	for i, v := range m.events {
  		fmt.Printf("%d;%+v\n", i, v)
  	}
  }
  
  func fail(format string, a ...any) error {
  	if crash {
  		panic(fmt.Sprintf(format, a...))
  	}
  	return fmt.Errorf(format, a...)
  }
  
  func (m *Monitor) CheckInitial(trace_i int, prev Event, this Event) error {
  
  	// X = 1
  	if IsFalse(Eq(this.State.X, Int(1))) {
  		return fail("precondition failed in Initial at %d; X = 1\n\nthis.State.X = %+v\n\nInt(1) = %+v", trace_i, this.State.X, Int(1))
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckA(trace_i int, prev Event, this Event) error {
  
  	// x < 0
  	if IsFalse(IntLt(any(prev.State.X).(Integer), Int(0))) {
  		return fail("precondition failed in A at %d; x < 0\n\nany(prev.State.X).(Integer) = %+v\n\nInt(0) = %+v", trace_i, any(prev.State.X).(Integer), Int(0))
  	}
  
  	// x' = x + 1
  	if IsFalse(Eq(this.State.X, IntPlus(any(prev.State.X).(Integer), Int(1)))) {
  		return fail("postcondition failed in A at %d; x' = x + 1\n\nthis.State.X = %+v\n\nIntPlus(any(prev.State.X).(Integer), Int(1)) = %+v", trace_i, this.State.X, IntPlus(any(prev.State.X).(Integer), Int(1)))
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckA1(trace_i int, prev Event, this Event) error {
  
  	// x < 0
  	if IsFalse(IntLt(any(prev.State.X).(Integer), Int(0))) {
  		return fail("precondition failed in A1 at %d; x < 0\n\nany(prev.State.X).(Integer) = %+v\n\nInt(0) = %+v", trace_i, any(prev.State.X).(Integer), Int(0))
  	}
  
  	// x' = x + 1 \land x < 0
  	if IsFalse(And(Eq(this.State.X, IntPlus(any(prev.State.X).(Integer), Int(1))), IntLt(any(prev.State.X).(Integer), Int(0)))) {
  		return fail("precondition failed in A1 at %d; x' = x + 1 \\land x < 0\n\nEq(this.State.X, IntPlus(any(prev.State.X).(Integer), Int(1))) = %+v\n\nIntLt(any(prev.State.X).(Integer), Int(0)) = %+v", trace_i, Eq(this.State.X, IntPlus(any(prev.State.X).(Integer), Int(1))), IntLt(any(prev.State.X).(Integer), Int(0)))
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckB(trace_i int, prev Event, this Event) error {
  
  	// UNCHANGED(x)
  	if IsFalse(Eq(this.State.X, prev.State.X)) {
  		return fail("precondition failed in B at %d; UNCHANGED(x)\n\nthis.State.X = %+v\n\nprev.State.X = %+v", trace_i, this.State.X, prev.State.X)
  	}
  
  	// UNCHANGED(vars)
  	if IsFalse(Eq(this.State.X, prev.State.X)) {
  		return fail("precondition failed in B at %d; UNCHANGED(vars)\n\nthis.State.X = %+v\n\nprev.State.X = %+v", trace_i, this.State.X, prev.State.X)
  	}
  
  	// UNCHANGED(<<x>>)
  	if IsFalse(Eq(this.State.X, prev.State.X)) {
  		return fail("precondition failed in B at %d; UNCHANGED(<<x>>)\n\nthis.State.X = %+v\n\nprev.State.X = %+v", trace_i, this.State.X, prev.State.X)
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckC(trace_i int, prev Event, this Event) error {
  
  	// Send(x)
  	if IsFalse(Eq(prev.State.X, prev.State.X)) {
  		return fail("precondition failed in C at %d; Send(x)\n\nprev.State.X = %+v\n\nprev.State.X = %+v", trace_i, prev.State.X, prev.State.X)
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckSendM(y TLA, trace_i int, prev Event, this Event) error {
  
  	// Send(y)
  	if IsFalse(Eq(prev.State.X, y)) {
  		return fail("precondition failed in SendM at %d; Send(y)\n\nprev.State.X = %+v\n\ny = %+v", trace_i, prev.State.X, y)
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckC1(trace_i int, prev Event, this Event) error {
  
  	// SendM(x)
  	if IsFalse(Eq(prev.State.X, prev.State.X)) {
  		return fail("precondition failed in C1 at %d; SendM(x)\n\nprev.State.X = %+v\n\nprev.State.X = %+v", trace_i, prev.State.X, prev.State.X)
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckD(trace_i int, prev Event, this Event) error {
  
  	if IsFalse(And(Eq(prev.State.X, Int(1)), Eq(this.State.X, Int(2)))) {
  
  		// ((x = 1 /\ x' = 2) \/ (x /= 1 /\ x' = 3))
  		if IsFalse(And(Neq(prev.State.X, Int(1)), Eq(this.State.X, Int(3)))) {
  			return fail("precondition failed in D at %d; ((x = 1 /\\ x' = 2) \\/ (x /= 1 /\\ x' = 3))\n\nNeq(prev.State.X, Int(1)) = %+v\n\nEq(this.State.X, Int(3)) = %+v", trace_i, Neq(prev.State.X, Int(1)), Eq(this.State.X, Int(3)))
  		}
  	}
  
  	return nil
  }
  
  func (monitor *Monitor) CheckE(trace_i int, prev Event, this Event) error {
  
  	if IsFalse(And(And(Eq(prev.State.X, Int(1)), Eq(this.State.X, Int(2))), Or(Eq(prev.State.X, Int(2)), And(Eq(prev.State.X, Int(3)), Eq(prev.State.X, Int(1)))))) {
  
  		// ((x = 1 /\ x' = 2) \/ (x /= 1 /\ x' = 3))
  		if IsFalse(And(Neq(prev.State.X, Int(1)), Eq(this.State.X, Int(3)))) {
  			return fail("precondition failed in E at %d; ((x = 1 /\\ x' = 2) \\/ (x /= 1 /\\ x' = 3))\n\nNeq(prev.State.X, Int(1)) = %+v\n\nEq(this.State.X, Int(3)) = %+v", trace_i, Neq(prev.State.X, Int(1)), Eq(this.State.X, Int(3)))
  		}
  	}
  
  	return nil
  }
  
  func (monitor *Monitor) CheckF(z TLA, trace_i int, prev Event, this Event) error {
  
  	// TRUE
  	if IsFalse(Bool(true)) {
  		return fail("precondition failed in F at %d; TRUE\n\n", trace_i)
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckG(trace_i int, prev Event, this Event) error {
  
  	// [["a" |-> 1] EXCEPT !["a"] = 2]["a"] = 2
  	if IsFalse(Eq(IndexInto(Except(Rec(Str("a"), Int(1)), Str("a"), Int(2)), Str("a")), Int(2))) {
  		return fail("precondition failed in G at %d; [[\"a\" |-> 1] EXCEPT ![\"a\"] = 2][\"a\"] = 2\n\nIndexInto(Except(Rec(Str(\"a\"), Int(1)), Str(\"a\"), Int(2)), Str(\"a\")) = %+v\n\nInt(2) = %+v", trace_i, IndexInto(Except(Rec(Str("a"), Int(1)), Str("a"), Int(2)), Str("a")), Int(2))
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckH(trace_i int, prev Event, this Event) error {
  
  	// \A r \in {1, 2} : r = 1
  	if IsFalse(BoundedForall(Set(Int(1), Int(2)), func(v0_r TLA) Boolean {
  
  		return Eq(v0_r, Int(1))
  	})) {
  		return fail("precondition failed in H at %d; \\A r \\in {1, 2} : r = 1\n\nSet(Int(1), Int(2)) = %+v\n\n\"<func>\" = %+v", trace_i, Set(Int(1), Int(2)), "<func>")
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckH1(trace_i int, prev Event, this Event) error {
  
  	// \A s \in {1, 2} : \A r \in {3, 4} : r = s
  	if IsFalse(BoundedForall(Set(Int(1), Int(2)), func(v1_s TLA) Boolean {
  
  		return BoundedForall(Set(Int(3), Int(4)), func(v2_r TLA) Boolean {
  
  			return Eq(v2_r, v1_s)
  		})
  	})) {
  		return fail("precondition failed in H1 at %d; \\A s \\in {1, 2} : \\A r \\in {3, 4} : r = s\n\nSet(Int(1), Int(2)) = %+v\n\n\"<func>\" = %+v", trace_i, Set(Int(1), Int(2)), "<func>")
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckH2(trace_i int, prev Event, this Event) error {
  
  	// [ r \in RM |-> "a" ]["a"] = 1
  	if IsFalse(Eq(IndexInto(FnConstruct(Set(Str("s1"), Str("2")), func(_ TLA) TLA {
  
  		return Str("a")
  	}), Str("a")), Int(1))) {
  		return fail("precondition failed in H2 at %d; [ r \\in RM |-> \"a\" ][\"a\"] = 1\n\nIndexInto(FnConstruct(Set(Str(\"s1\"), Str(\"2\")), func(_ TLA) TLA {  return Str(\"a\") }), Str(\"a\")) = %+v\n\nInt(1) = %+v", trace_i, IndexInto(FnConstruct(Set(Str("s1"), Str("2")), func(_ TLA) TLA {
  
  			return Str("a")
  		}), Str("a")), Int(1))
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckH3(trace_i int, prev Event, this Event) error {
  
  	// [ r \in RM |-> r ]["a"] = 1
  	if IsFalse(Eq(IndexInto(FnConstruct(Set(Str("s1"), Str("2")), func(v4 TLA) TLA {
  
  		return any(v4).(Set_)
  	}), Str("a")), Int(1))) {
  		return fail("precondition failed in H3 at %d; [ r \\in RM |-> r ][\"a\"] = 1\n\nIndexInto(FnConstruct(Set(Str(\"s1\"), Str(\"2\")), func(v4 TLA) TLA {  return any(v4).(Set_) }), Str(\"a\")) = %+v\n\nInt(1) = %+v", trace_i, IndexInto(FnConstruct(Set(Str("s1"), Str("2")), func(v4 TLA) TLA {
  
  			return any(v4).(Set_)
  		}), Str("a")), Int(1))
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckH4(trace_i int, prev Event, this Event) error {
  
  	if IsFalse(BoundedForall(Set(Int(1), Int(2)), func(v5_r TLA) Boolean {
  
  		return Eq(v5_r, Int(1))
  	})) {
  
  		// (\A r \in {1, 2} : r = 1 \/ \A r \in {2, 3} : r = 2)
  		if IsFalse(BoundedForall(Set(Int(2), Int(3)), func(v6_r TLA) Boolean {
  
  			return Eq(v6_r, Int(2))
  		})) {
  			return fail("precondition failed in H4 at %d; (\\A r \\in {1, 2} : r = 1 \\/ \\A r \\in {2, 3} : r = 2)\n\nSet(Int(2), Int(3)) = %+v\n\n\"<func>\" = %+v", trace_i, Set(Int(2), Int(3)), "<func>")
  		}
  	}
  
  	return nil
  }
  
  /* Action I cannot be translated because of: ToTrace(CounterExample) */
  
  func (monitor *Monitor) Checka(trace_i int, prev Event, this Event) error {
  
  	// 1
  	if IsFalse(Int(1)) {
  		return fail("check failed in a at %d; 1\n\n", trace_i)
  	}
  	return nil
  }
  
  func (monitor *Monitor) Checkb(trace_i int, prev Event, this Event) error {
  
  	// 1
  	if IsFalse(Int(1)) {
  		return fail("check failed in b at %d; 1\n\n", trace_i)
  	}
  	return nil
  }
  
  func (monitor *Monitor) Checkc(trace_i int, prev Event, this Event) error {
  
  	// 1
  	if IsFalse(Int(1)) {
  		return fail("check failed in c at %d; 1\n\n", trace_i)
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckI1(trace_i int, prev Event, this Event) error {
  
  	var a TLA = Int(1)
  	var b TLA = Int(1)
  	var c TLA = Int(1)
  	// a + b + c = 1
  	if IsFalse(Eq(IntPlus(IntPlus(any(a).(Integer), any(b).(Integer)), any(c).(Integer)), Int(1))) {
  		return fail("precondition failed in I1 at %d; a + b + c = 1\n\nIntPlus(IntPlus(any(a).(Integer), any(b).(Integer)), any(c).(Integer)) = %+v\n\nInt(1) = %+v", trace_i, IntPlus(IntPlus(any(a).(Integer), any(b).(Integer)), any(c).(Integer)), Int(1))
  	}
  	return nil
  }
  
  func (monitor *Monitor) CheckSets(trace_i int, prev Event, this Event) error {
  
  	// {1, 2} \union {3} = {}
  	if IsFalse(Eq(SetUnion(Set(Int(1), Int(2)), Set(Int(3))), Set())) {
  		return fail("precondition failed in Sets at %d; {1, 2} \\union {3} = {}\n\nSetUnion(Set(Int(1), Int(2)), Set(Int(3))) = %+v\n\nSet() = %+v", trace_i, SetUnion(Set(Int(1), Int(2)), Set(Int(3))), Set())
  	}
  
  	// 1 \notin {3}
  	if IsFalse(SetNotIn(Int(1), Set(Int(3)))) {
  		return fail("precondition failed in Sets at %d; 1 \\notin {3}\n\nInt(1) = %+v\n\nSet(Int(3)) = %+v", trace_i, Int(1), Set(Int(3)))
  	}
  	return nil
  }
  
  /*
  func (m *Monitor) CheckInc(i int, prev Event, this Event) error {
  
  	if prev.state.x.(int) <= 0 {
  		return fail("precondition failed at %d; expected x <= 0 but got %s (prev: %+v, this: %+v)", i, prev.state.x, prev, this)
  	}
  	// check that new values are allowed
  	if this.state.x != prev.state.x.(int)+1 { // for each var
  		return fail("postcondition violated for x at %d; should be %+v but got %+v (prev: %+v, this: %+v)", i,
  			prev.state.x.(int)+1, this.state.x, prev, this)
  	}
  
  	// check unchanged
  	if this.state.x != prev.state.x { // for each var
  		return fail("unchanged violated for x at %d; expected x to remain as %+v but it is %+v (prev: %+v, this: %+v)", i, prev.state.x, this.state.x, prev, this)
  	}
  
  	return nil
  }
  */
  
  // this state value can have nil fields
  func (m *Monitor) CaptureVariable(v State, typ EventType, args ...TLA) error {
  	if len(args) == 0 {
  		args = []TLA{}
  	}
  
  	e := Event{
  		Typ:    typ,
  		Params: args,
  		State:  v,
  		// no need to capture file and line here
  	}
  	m.extra = append(m.extra, e)
  	return nil
  }
  
  func (m *Monitor) CaptureState(c State, typ EventType, args ...TLA) error {
  	if len(args) == 0 {
  		args = []TLA{}
  	}
  
  	// override current values with extras
  	// all have to pertain to this action
  	for _, v := range m.extra {
  		// sanity checks
  		if v.Typ != typ {
  			return fmt.Errorf("type did not match")
  		}
  		for i, p := range v.Params {
  			if p != args[i] {
  				return fmt.Errorf("arg %d did not match", i)
  			}
  		}
  		// there is no null in TLA+, and also all the struct fields are any, which are reference types
  
  		// for each variable in state
  		if v.State.X != nil {
  			c.X = v.State.X
  		}
  	}
  
  	// reset
  	m.extra = []Event{}
  
  	// record event
  	file, line := getFileLine()
  	e := Event{
  		Typ:    typ,
  		Params: args,
  		State:  c,
  		File:   file,
  		Line:   line,
  	}
  
  	m.events = append(m.events, e)
  	if writeLog {
  		logEvent(m.who.value, e)
  	}
  	if online {
  		if err := m.CheckLast(); err != nil {
  			return err
  		}
  	}
  
  	return nil
  }

  $ monitor_check Counter
  766 lines
  parse ok
  compile ok

  $ monitor_check TwoPhaseCommitFull
  1299 lines
  parse ok
  compile ok

  $ monitor_check raft
  1834 lines
  parse ok
  compile ok
